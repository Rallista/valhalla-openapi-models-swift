//
// Thor.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct Thor: Codable, Hashable {
    public var clearReservedMemory: Bool? = false
    public var extendedSearch: Bool? = false
    public var logging: ThorLogging?
    public var maxReservedLabelsCount: Int? = 1_000_000
    public var service: ThorService?
    public var sourceToTargetAlgorithm: String? = "select_optimal"

    public init(clearReservedMemory: Bool? = false, extendedSearch: Bool? = false, logging: ThorLogging? = nil, maxReservedLabelsCount: Int? = 1_000_000, service: ThorService? = nil, sourceToTargetAlgorithm: String? = "select_optimal") {
        self.clearReservedMemory = clearReservedMemory
        self.extendedSearch = extendedSearch
        self.logging = logging
        self.maxReservedLabelsCount = maxReservedLabelsCount
        self.service = service
        self.sourceToTargetAlgorithm = sourceToTargetAlgorithm
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case clearReservedMemory = "clear_reserved_memory"
        case extendedSearch = "extended_search"
        case logging
        case maxReservedLabelsCount = "max_reserved_labels_count"
        case service
        case sourceToTargetAlgorithm = "source_to_target_algorithm"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(clearReservedMemory, forKey: .clearReservedMemory)
        try container.encodeIfPresent(extendedSearch, forKey: .extendedSearch)
        try container.encodeIfPresent(logging, forKey: .logging)
        try container.encodeIfPresent(maxReservedLabelsCount, forKey: .maxReservedLabelsCount)
        try container.encodeIfPresent(service, forKey: .service)
        try container.encodeIfPresent(sourceToTargetAlgorithm, forKey: .sourceToTargetAlgorithm)
    }
}
